// Copyright 2016-2017, Bernard Helyer.
// SPDX-License-Identifier: BSL-1.0
/*!
 * Code to support spawning new threads.
 *
 * The runtime has to be aware of new threads in order
 * to make GC work, so all new threads should be
 * spawned through this interface.
 */

module vrt.os.thread;
version (!Metal):

import vrt.gc.util;

import core.exception;
import core.rt.misc: vrt_run_local_ctors, vrt_run_local_dtors;
import core.rt.gc: vrt_gc_init, allocDg, vrt_gc_get_alloc_dg, vrt_gc_shutdown;

version (Windows) {
	import core.c.windows;
} else {
	import core.c.pthread;
	import core.c.posix.unistd;

	version (Linux) {
		enum EPERM    = 1;
		enum EAGAIN   = 11;
		enum EINVAL   = 22;
		enum EDEADLK  = 35;
	} else version (OSX) {
		enum EPERM    = 1;
		enum EAGAIN   = 35;
		enum EINVAL   = 22;
		enum EDEADLK  = 11;
	} else {
		static assert(false, "define errno values in vrt.os.thread");
	}
}

struct vrt_thread
{
private:
	version (Windows) {
		mThreadId: DWORD;
		mHandle: HANDLE;
	} else {
		mHandle: pthread_t;
		mErrorCode: i32;
	}
	mError: bool;
	/* If these aren't kept on the parent thread,
	 * they may be collected.
	 */
	mAdaptorPointer, mDelegatePointer: void*;
}

struct vrt_mutex
{
private:
	version (Windows) {
		mHandle: HANDLE;
	} else {
		mMutex: pthread_mutex_t;
	}
}

extern (C) fn vrt_mutex_new() vrt_mutex*
{
	mutex := new vrt_mutex;
	version (Windows) {
		mutex.mHandle = CreateMutexA(null, FALSE, null);
		if (mutex.mHandle is null) {
			throw new Exception("could not create mutex");
		}
	} else {
		rv := pthread_mutex_init(&mutex.mMutex, null);
		if (rv != 0) {
			throw new Exception("could not create mutex");
		}
	}
	return mutex;
}

extern (C) fn vrt_mutex_trylock(mutex: vrt_mutex*) bool
{
	version (Windows) {
		return waitForSingleObject(mutex.mHandle, 0);
	} else {
		return pthread_mutex_trylock(&mutex.mMutex) == 0;
	}
}

extern (C) fn vrt_mutex_lock(mutex: vrt_mutex*) bool
{
	version (Windows) {
		return waitForSingleObject(mutex.mHandle, INFINITE);
	} else {
		rv := pthread_mutex_lock(&mutex.mMutex);
		if (rv != 0) {
			throw new Exception("error in acquiring mutex lock");
		}
		return true;
	}
}

extern (C) fn vrt_mutex_unlock(mutex: vrt_mutex*)
{
	version (Windows) {
		ReleaseMutex(mutex.mHandle);
	} else {
		rv := pthread_mutex_unlock(&mutex.mMutex);
		if (rv != 0) {
			throw new Exception("error in unlocking mutex");
		}
	}
}

extern (C) fn vrt_mutex_delete(mutex: vrt_mutex*)
{
	version (Windows) {
		CloseHandle(mutex.mHandle);
	} else {
		pthread_mutex_destroy(&mutex.mMutex);
	}
}

struct FunctionAdaptor
{
	ptr: fn();
	fn dgt()
	{
		ptr();
	}
}

extern (C) fn vrt_thread_start_fn(func: fn()) vrt_thread*
{
	fa := new FunctionAdaptor;
	fa.ptr = func;
	t := vrt_thread_start_dg(fa.dgt);
	t.mAdaptorPointer = cast(void*)fa;
	return t;
}

extern (C) fn vrt_thread_start_dg(dlgt: dg()) vrt_thread*
{
	dgptr := new dg();
	*dgptr = dlgt;
	t := new vrt_thread;
	t.mDelegatePointer = cast(void*)dgptr;
	version (Windows) {
		t.mHandle = CreateThread(null, 0, __vrt_thread_proc, cast(void*)dgptr, 0, &t.mThreadId);
		t.mError  = t.mHandle is null;
	} else {
		t.mErrorCode  = pthread_create(&t.mHandle, null, __vrt_thread_proc, cast(void*)dgptr);
		t.mError = t.mErrorCode != 0;
	}
	return t;
}

extern (C) fn vrt_thread_error(t: vrt_thread*) bool
{
	return t.mError;
}

extern (C) fn vrt_thread_error_message(t: vrt_thread*) string
{
	if (!t.mError) {
		return "Operation performed successfully.";
	}
	version (Windows) {
		code := GetLastError();
		msg: char*;
		flags := cast(DWORD)(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ALLOCATE_BUFFER);
		count := FormatMessageA(flags, null, code, 0, cast(LPCSTR)&msg, 0, null);
		buf   := new char[](count);
		buf[0 .. count] = msg[0 .. count];
		LocalFree(cast(HLOCAL)msg);
		return cast(string)buf;
	} else {
		switch (t.mErrorCode) {
		case EAGAIN:  return "The system lacked, or restricted, the necessary resources. (EAGAIN)";
		case EINVAL:  return "An invalid argument was given to a function. (EINVAL)";
		case EPERM:   return "The caller does not have appropriate permission. (EPERM)";
		case EDEADLK: return "A deadlock was detected. (EDEADLK)";
		default:      return "The operation encountered an error, but no further information was given.";
		}
	}
}

extern (C) fn vrt_thread_join(t: vrt_thread*)
{
	version (Windows) {
		retval := WaitForSingleObject(t.mHandle, INFINITE);
		t.mHandle = null;
		t.mError = retval == cast(DWORD)0xFFFFFFFF;
	} else {
		t.mErrorCode = pthread_join(t.mHandle, null);
		t.mError = t.mErrorCode != 0;
	}
}

extern (C) fn vrt_sleep(ms: u32)
{
	version (Windows) {
		Sleep(ms);
	} else {
		usleep(ms * 1000);
	}
}

/*!
 * The bottom of the stack.
 *
 * Initialised by vrt_gc_find_stack_bottom function, called in the
 * main function generated by the compiler.
 */
local __stack_bottom: void*;

fn vrt_get_stack_bottom() void*
{
	gcAssert(__stack_bottom !is null);
	return __stack_bottom;
}

private:

version (Windows) fn waitForSingleObject(handle: HANDLE, timeout: DWORD) bool
{
	rv := WaitForSingleObject(handle, timeout);
	switch (rv) {
	case WAIT_OBJECT_0:
		return true;
	case WAIT_TIMEOUT:
		return false;
	case WAIT_ABANDONED:
		throw new Exception("mutex has been abandoned (a thread terminated holding the lock)");
	default:
		throw new Exception("an error occured trying to gain ownership of a mutex");
	}
}

version (Windows) extern (Windows) fn __vrt_thread_proc(ptr: LPVOID) DWORD
{
	vrt_thread_proc(ptr);
	return 0;
}
else extern (C) fn __vrt_thread_proc(ptr: void*) void*
{
	vrt_thread_proc(ptr);
	return null;
}

fn vrt_thread_proc(ptr: void*)
{
	__stack_bottom = cast(void*)&ptr;
	vrt_gc_init();
	allocDg = vrt_gc_get_alloc_dg();

	dgt := *(cast(dg()*)ptr);

	vrt_run_local_ctors();
	dgt();
	vrt_run_local_dtors();

	vrt_gc_shutdown();
}
