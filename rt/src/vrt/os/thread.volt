// Copyright 2016-2017, Bernard Helyer.
// SPDX-License-Identifier: BSL-1.0
/*!
 * Code to support spawning new threads.
 *
 * The runtime has to be aware of new threads in order
 * to make GC work, so all new threads should be
 * spawned through this interface.
 */

module vrt.os.thread;
version (!Metal):

import vrt.gc.util;

import core.rt.misc: vrt_run_local_ctors, vrt_run_local_dtors;
import core.rt.gc: vrt_gc_init, allocDg, vrt_gc_get_alloc_dg, vrt_gc_shutdown;

version (Windows) {
	import core.c.windows;
} else {
	import core.c.pthread;
	import core.c.posix.unistd;

	version (Linux) {
		enum EPERM    = 1;
		enum EAGAIN   = 11;
		enum EINVAL   = 22;
		enum EDEADLK  = 35;
	} else version (OSX) {
		enum EPERM    = 1;
		enum EAGAIN   = 35;
		enum EINVAL   = 22;
		enum EDEADLK  = 11;
	} else {
		static assert(false, "define errno values in vrt.os.thread");
	}
}

/*!
 * An opaque data type representing a thread.
 */
struct vrt_thread
{
private:
	version (Windows) {
		mThreadId: DWORD;
		mHandle: HANDLE;
	} else {
		mHandle: pthread_t;
		mErrorCode: i32;
	}
	mError: bool;
	/* If these aren't kept on the parent thread,
	 * they may be collected.
	 */
	mAdaptorPointer, mDelegatePointer: void*;
}

struct FunctionAdaptor
{
	ptr: fn();
	fn dgt()
	{
		ptr();
	}
}

extern (C) fn vrt_thread_start_fn(func: fn()) vrt_thread*
{
	fa := new FunctionAdaptor;
	fa.ptr = func;
	t := vrt_thread_start_dg(fa.dgt);
	t.mAdaptorPointer = cast(void*)fa;
	return t;
}

extern (C) fn vrt_thread_start_dg(dlgt: dg()) vrt_thread*
{
	dgptr := new dg();
	*dgptr = dlgt;
	t := new vrt_thread;
	t.mDelegatePointer = cast(void*)dgptr;
	version (Windows) {
		t.mHandle = CreateThread(null, 0, __vrt_thread_proc, cast(void*)dgptr, 0, &t.mThreadId);
		t.mError  = t.mHandle is null;
	} else {
		t.mErrorCode  = pthread_create(&t.mHandle, null, __vrt_thread_proc, cast(void*)dgptr);
		t.mError = t.mErrorCode != 0;
	}
	return t;
}

extern (C) fn vrt_thread_error(t: vrt_thread*) bool
{
	return t.mError;
}

extern (C) fn vrt_thread_error_message(t: vrt_thread*) string
{
	if (!t.mError) {
		return "Operation performed successfully.";
	}
	version (Windows) {
		code := GetLastError();
		msg: char*;
		flags := cast(DWORD)(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ALLOCATE_BUFFER);
		count := FormatMessageA(flags, null, code, 0, cast(LPCSTR)&msg, 0, null);
		buf   := new char[](count);
		buf[0 .. count] = msg[0 .. count];
		LocalFree(cast(HLOCAL)msg);
		return cast(string)buf;
	} else {
		switch (t.mErrorCode) {
		case EAGAIN:  return "The system lacked, or restricted, the necessary resources. (EAGAIN)";
		case EINVAL:  return "An invalid argument was given to a function. (EINVAL)";
		case EPERM:   return "The caller does not have appropriate permission. (EPERM)";
		case EDEADLK: return "A deadlock was detected. (EDEADLK)";
		default:      return "The operation encountered an error, but no further information was given.";
		}
	}
}

extern (C) fn vrt_thread_join(t: vrt_thread*)
{
	version (Windows) {
		retval := WaitForSingleObject(t.mHandle, INFINITE);
		t.mHandle = null;
		t.mError = retval == cast(DWORD)0xFFFFFFFF;
	} else {
		t.mErrorCode = pthread_join(t.mHandle, null);
		t.mError = t.mErrorCode != 0;
	}
}

extern (C) fn vrt_sleep(ms: u32)
{
	version (Windows) {
		Sleep(ms);
	} else {
		usleep(ms * 1000);
	}
}

/*!
 * The bottom of the stack.
 *
 * Initialised by vrt_gc_find_stack_bottom function, called in the
 * main function generated by the compiler.
 */
local __stack_bottom: void*;

fn vrt_get_stack_bottom() void*
{
	gcAssert(__stack_bottom !is null);
	return __stack_bottom;
}

private:

version (Windows) extern (Windows) fn __vrt_thread_proc(ptr: LPVOID) DWORD
{
	vrt_thread_proc(ptr);
	return 0;
}
else extern (C) fn __vrt_thread_proc(ptr: void*) void*
{
	vrt_thread_proc(ptr);
	return null;
}

fn vrt_thread_proc(ptr: void*)
{
	__stack_bottom = cast(void*)&ptr;
	vrt_gc_init();
	allocDg = vrt_gc_get_alloc_dg();

	dgt := *(cast(dg()*)ptr);

	vrt_run_local_ctors();
	dgt();
	vrt_run_local_dtors();

	vrt_gc_shutdown();
}
